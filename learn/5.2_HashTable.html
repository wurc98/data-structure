<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>哈希表</title>
	</head>
	<body>
		<script type="text/javascript">
			//链地址法
			class HashTable {
				constructor() {
					this.storage = []
					this.count = 0 //用于计算loadFactor  >0.75时，进行扩容
					this.limit = 16
				}
				HashFn(str) {
					var hashCode = 0;
					for (let i = 0; i < str.length; i++) {
						hashCode = hashCode * 37 + str.charCodeAt(i)
					}
					var index = hashCode % this.limit
					return index
				}
				/**
				 *  插入和修改是同一个方法，哈希表不允许重复
				 *   1、根据key获取索引值。 目的==>> 将数据插入到对于的位置
				 *   2、根据索引值取出bucket(桶)
				 *   	1>、判断bucket是否存在，不存在就要创建，并放置在该索引的位置
				 * 	 3、判断新增还是修改原来的值。
				 * */
				put(key, value) {
					//1
					var index = this.HashFn(key)
					//2
					var bucket = this.storage[index]
					if (bucket == null) {
						bucket = []
						this.storage[index] = bucket
					}
					//3
					for (let i = 0; i < bucket.length; i++) {
						var tuple = bucket[i]
						if (tuple[0] == key) {
							tuple[1] = value
						}
					}
					bucket.push([key, value])
					this.count++
				}
				get(key) {
					//1
					var index = this.HashFn(key)
					//2
					var bucket = this.storage[index]
					if (bucket == null) {
						return "没有"
					}
					//3
					for (let i = 0; i < bucket.length; i++) {
						var tuple = bucket[i]
						if (tuple[0] == key) {
							return tuple[1]
						}
					}
				}
				remove(key) {
					//1
					var index = this.HashFn(key)
					//2
					var bucket = this.storage[index]
					if (bucket == null) {
						return "没有此元素"
					}
					//3
					for (let i = 0; i < bucket.length; i++) {
						var tuple = bucket[i]
						if (tuple[0] == key) {
							bucket.splice(i, 1)
							this.count--
							return "success:" + tuple[1]
						}
						return "没有此元素"
					}
				}
			}
			var ht = new HashTable()
			ht.put('abc',"123")
			ht.put('bbc',"456")
			ht.put('cbc',"789")
			console.log(ht.get('abc'))
			ht.put('abc',"111")
			console.log(ht.get('abc'))
			console.log(ht.remove('abc'))
		</script>
	</body>
</html>
